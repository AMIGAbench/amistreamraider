"""Manage streamlink/ffmpeg/mbuffer transcoding pipelines."""

from __future__ import annotations

import asyncio
import contextlib
import os
import shlex
import signal
import sys
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, TextIO
import textwrap


@dataclass(frozen=True)
class TranscodeProfile:
    name: str
    output_args: List[str]
    description: Optional[str] = None
    listen_port: Optional[int] = None


@dataclass
class PipelineStatus:
    op_id: str
    channel: str
    profile: str
    started_at: float
    state: str
    listen_host: str
    listen_port: int
    outfile: Path
    log_file: Path
    pgid: Optional[int] = None
    ended_at: Optional[float] = None
    restart_count: int = 0
    last_error: Optional[str] = None


@dataclass
class PipelineMetrics:
    op_id: str
    bytes_total: int = 0
    out_time_ms: int = 0
    bitrate_kbps: int = 0
    updated_at: float = field(default_factory=lambda: time.time())


@dataclass
class _PipelineRuntime:
    status: PipelineStatus
    profile: TranscodeProfile
    channel: str
    processes: List[asyncio.subprocess.Process] = field(default_factory=list)
    log_handle: Optional[TextIO] = None
    metrics: PipelineMetrics | None = None
    monitor_task: Optional[asyncio.Task] = None
    metrics_task: Optional[asyncio.Task] = None
    pump_tasks: List[asyncio.Task] = field(default_factory=list)
    stop_requested: bool = False
    restart_attempts: int = 0
    bytes_total: int = 0
    last_reported_bytes: int = 0
    last_activity_ts: float = field(default_factory=lambda: time.time())
    client_connected: bool = False
    # Offscreen resources
    offscreen_sink_module_id: Optional[str] = None
    offscreen_sink_name: Optional[str] = None
    offscreen_display: Optional[str] = None
    placeholder_task: Optional[asyncio.Task] = None
    placeholder_active: bool = False
    output_placeholder_task: Optional[asyncio.Task] = None
    output_placeholder_active: bool = False


class TranscodeManager:
    """Launch and supervise streamlink→ffmpeg→mbuffer→ffmpeg pipelines."""

    def __init__(
        self,
        *,
        work_dir: Path,
        profiles: Dict[str, TranscodeProfile],
        streamlink_path: str = "streamlink",
        ffmpeg_path: str = "ffmpeg",
        mbuffer_path: str = "mbuffer",
        listen_host: str = "0.0.0.0",
        default_listen_port: int = 5001,
    ) -> None:
        self.work_dir = work_dir
        self.work_dir.mkdir(parents=True, exist_ok=True)
        self._strategy_file = self.work_dir / ".strategy"
        self.profiles = profiles
        self.streamlink_path = streamlink_path
        self.ffmpeg_path = ffmpeg_path
        self.mbuffer_path = mbuffer_path
        self.listen_host = listen_host
        self.default_listen_port = default_listen_port
        self._pipelines: Dict[str, _PipelineRuntime] = {}
        self._metrics_interval = 1.0
        self.max_restarts = int(os.getenv("TRANSCODE_MAX_RESTARTS", "3"))
        self.restart_delay = float(os.getenv("TRANSCODE_RESTART_DELAY", "5"))
        self.autostop_idle = float(os.getenv("TRANSCODE_AUTOSTOP_IDLE", "10"))
        # Additional runtime tuning
        self.prebuffer_seconds = float(os.getenv("TRANSCODE_PREBUFFER_SECONDS", "5"))
        # Default: disable ads in streamlink (can be overridden with STREAMLINK_DISABLE_ADS=0)
        self.streamlink_disable_ads = os.getenv("STREAMLINK_DISABLE_ADS", "1") != "0"
        seg_stream_data = os.getenv("STREAMLINK_HLS_SEGMENT_STREAM_DATA", "--hls-segment-stream-data").strip()
        live_edge = os.getenv("STREAMLINK_HLS_LIVE_EDGE", "2").strip()
        seg_threads = os.getenv("STREAMLINK_HLS_SEGMENT_THREADS", "3").strip()
        default_streamlink = (
            f"--twitch-disable-ads "
            f"{seg_stream_data} "
            f"--hls-live-edge {live_edge} "
            f"--stream-segment-threads {seg_threads}"
        )
        raw_streamlink_args = os.getenv("TRANSCODE_STREAMLINK_ARGS", default_streamlink).strip()
        self.streamlink_args = shlex.split(raw_streamlink_args) if raw_streamlink_args else []
        self.mbuffer_size = os.getenv("TRANSCODE_MBUFFER_SIZE", "4M").strip() or "4M"
        # Strategy: direct (default) or offscreen
        self._strategy = os.getenv("TRANSCODE_STRATEGY", "offscreen").lower()
        # Offscreen defaults (can be overridden via ENV)
        self.offscreen_display = os.getenv("OFFSCREEN_DISPLAY", ":99")
        self.offscreen_width = int(os.getenv("OFFSCREEN_WIDTH", "640"))
        # Optional height for Xvfb screen; 640x360 as robust 16:9 default
        self.offscreen_height = int(os.getenv("OFFSCREEN_HEIGHT", "360"))
        self.offscreen_fps = int(os.getenv("OFFSCREEN_FPS", "24"))
        self.offscreen_quality = os.getenv("OFFSCREEN_QUALITY", "720p,480p,best")
        self.offscreen_mbuffer = os.getenv("OFFSCREEN_MBUFFER", "1G")
        self.offscreen_live_wait = float(os.getenv("OFFSCREEN_LIVE_WAIT", "3"))
        self.offscreen_capture_delay = float(os.getenv("OFFSCREEN_CAPTURE_DELAY", "3"))
        assets_dir = Path(__file__).resolve().parents[1] / "assets"
        placeholder_img = assets_dir / "videoinsert.jpg"
        placeholder_ts = assets_dir / "placeholders" / "joiner_h264_aac.ts"
        placeholder_env = os.getenv("OFFSCREEN_PLACEHOLDER_ASSET") or os.getenv(
            "OFFSCREEN_PLACEHOLDER_IMAGE"
        )
        default_placeholder = placeholder_ts if placeholder_ts.exists() else placeholder_img
        self.offscreen_placeholder_asset = Path(
            placeholder_env or default_placeholder
        )
        self.offscreen_placeholder_duration = float(
            os.getenv("OFFSCREEN_PLACEHOLDER_DURATION", "0")
        )
        self.offscreen_placeholder_runtime = float(
            os.getenv("OFFSCREEN_PLACEHOLDER_RUNTIME", "15")
        )
        self.offscreen_audio_delay = float(os.getenv("OFFSCREEN_AUDIO_DELAY_MS", "500")) / 1000.0
        self.repo_root = Path(__file__).resolve().parents[2]
        self.tcp_wrapper_path = Path(
            os.getenv("TRANSCODE_TCP_WRAPPER", str(self.repo_root / "scripts" / "tcp_wrapper.py"))
        )
        self.fifo_switch_path = Path(
            os.getenv("TRANSCODE_FIFO_SWITCH", str(self.repo_root / "scripts" / "fifo_switch.py"))
        )
        placeholder_default = self.repo_root / "server" / "assets" / "placeholders" / "joiner_h264_aac.ts"
        self.direct_placeholder_path = Path(
            os.getenv("TRANSCODE_JOINER_PLACEHOLDER", str(placeholder_default))
        )
        if self._strategy_file.exists():
            try:
                stored_strategy = self._strategy_file.read_text(encoding="utf-8").strip().lower()
                if stored_strategy in ("direct", "offscreen"):
                    self._strategy = stored_strategy
            except Exception:
                pass

    # Strategy control
    @property
    def strategy(self) -> str:
        return self._strategy

    async def set_strategy(self, strategy: str) -> None:
        strategy = strategy.lower()
        if strategy not in ("direct", "offscreen"):
            raise ValueError("Invalid strategy. Use 'direct' or 'offscreen'.")
        self._strategy = strategy
        try:
            self._strategy_file.write_text(self._strategy, encoding="utf-8")
        except Exception:
            pass

    def available_profiles(self) -> List[TranscodeProfile]:
        return list(self.profiles.values())

    def get_status(self, op_id: str) -> Optional[PipelineStatus]:
        runtime = self._pipelines.get(op_id)
        if runtime:
            return runtime.status
        return None

    def get_metrics(self, op_id: str) -> Optional[PipelineMetrics]:
        runtime = self._pipelines.get(op_id)
        if not runtime:
            return None
        self._update_metrics(runtime)
        return runtime.metrics

    def _placeholder_available(self) -> bool:
        return (
            self.offscreen_placeholder_asset is not None
            and self.offscreen_placeholder_asset.exists()
        )

    def _log_offscreen(self, runtime: _PipelineRuntime, message: str) -> None:
        handle = runtime.log_handle
        if not handle or handle.closed:
            return
        handle.write(f"[offscreen] {message}\n")
        handle.flush()

    def _build_direct_wrapper_command(
        self,
        *,
        profile: TranscodeProfile,
        channel: str,
        listen_port: int,
        op_id: str,
    ) -> List[str]:
        if not self.direct_placeholder_path.exists():
            raise FileNotFoundError(
                f"Direct placeholder not found: {self.direct_placeholder_path}"
            )
        url = f"https://www.twitch.tv/{channel}"
        fifo_path = self.work_dir / f"{op_id}.direct.fifo"
        streamlink_cmd = [
            self.streamlink_path,
            *self.streamlink_args,
            "--stdout",
            url,
            "best",
        ]
        ffmpeg_copy_cmd = [
            self.ffmpeg_path,
            "-loglevel",
            "error",
            "-y",
            "-re",
            "-i",
            "pipe:0",
            "-c",
            "copy",
            "-fflags",
            "+genpts",
            "-muxpreload",
            "0",
            "-muxdelay",
            "0",
            "-f",
            "mpegts",
            "pipe:1",
        ]
        mbuffer_cmd = [
            self.mbuffer_path,
            "-m",
            self.mbuffer_size,
            "-q",
        ]
        audio_filter = "aresample=async=1:first_pts=0"
        merged_output_args: List[str] = []
        i = 0
        while i < len(profile.output_args):
            arg = profile.output_args[i]
            if arg == "-af" and i + 1 < len(profile.output_args):
                original = profile.output_args[i + 1]
                combined = f"{audio_filter},{original}" if original else audio_filter
                merged_output_args.extend(["-af", combined])
                i += 2
                continue
            merged_output_args.append(arg)
            i += 1
        if "-af" not in merged_output_args:
            merged_output_args.extend(["-af", audio_filter])

        ffmpeg_encode_cmd = [
            self.ffmpeg_path,
            "-loglevel",
            "error",
            "-y",
            "-fflags",
            "+genpts",
            "-f",
            "mpegts",
            "-i",
            "pipe:0",
            "-use_wallclock_as_timestamps",
            "1",
            "-rw_timeout",
            "10000000",
            "-timeout",
            "10000000",
            "-flags",
            "+global_header",
            "-reconnect",
            "1",
            "-reconnect_at_eof",
            "1",
            "-reconnect_streamed",
            "1",
            "-reconnect_delay_max",
            "5",
            *merged_output_args,
            "-f",
            "mpeg",
            "pipe:1",
        ]

        placeholder_cmd = [
            self.ffmpeg_path,
            "-loglevel",
            "error",
            "-y",
            "-re",
            "-stream_loop",
            "-1",
            "-i",
            str(self.direct_placeholder_path),
            "-c",
            "copy",
            "-f",
            "mpegts",
            "pipe:1",
        ]

        def join(cmd: List[str]) -> str:
            return " ".join(shlex.quote(arg) for arg in cmd)

        writer_cmd = [
            sys.executable,
            "-u",
            str(self.fifo_switch_path),
            "--fifo",
            str(fifo_path),
            "--placeholder-cmd",
            join(placeholder_cmd),
            "--live-cmd",
            " | ".join(
                [
                    join(streamlink_cmd),
                    join(ffmpeg_copy_cmd),
                ]
            ),
        ]

        post_chain = f"cat {shlex.quote(str(fifo_path))} | {join(mbuffer_cmd)} | {join(ffmpeg_encode_cmd)}"
        fifo_q = shlex.quote(str(fifo_path))
        shell_pipeline = (
            f'trap "kill 0; rm -f {fifo_q}" INT TERM EXIT; '
            f"rm -f {fifo_q}; mkfifo {fifo_q}; "
            f"{join(writer_cmd)} & "
            f"{post_chain}; "
            "wait"
        )
        return [
            sys.executable,
            "-u",
            str(self.tcp_wrapper_path),
            "--host",
            self.listen_host,
            "--port",
            str(listen_port),
            "--cmd",
            shell_pipeline,
        ]

    async def _stop_placeholder(self, runtime: _PipelineRuntime) -> None:
        task = runtime.placeholder_task
        if not task:
            return
        runtime.placeholder_task = None
        runtime.placeholder_active = False
        task.cancel()
        await asyncio.gather(task, return_exceptions=True)

    async def _cancel_placeholder_after(self, runtime: _PipelineRuntime, duration: float) -> None:
        await asyncio.sleep(duration)
        if runtime.placeholder_task and not runtime.placeholder_task.done():
            await self._stop_placeholder(runtime)

    async def _launch_placeholder(
        self,
        runtime: _PipelineRuntime,
        writer: Optional[asyncio.StreamWriter],
        log_handle: TextIO,
    ) -> None:
        if not writer or not self._placeholder_available():
            return

        async def _run() -> None:
            asset = self.offscreen_placeholder_asset
            suffix = asset.suffix.lower()
            is_video_asset = suffix in {".ts", ".mpg", ".mpeg", ".mp4", ".mkv", ".mov", ".m4v"}
            if is_video_asset:
                cmd = [
                    self.ffmpeg_path,
                    "-hide_banner",
                    "-loglevel",
                    "error",
                    "-stream_loop",
                    "-1",
                    "-re",
                    "-i",
                    str(asset),
                    "-c",
                    "copy",
                    "-f",
                    "mpegts",
                    "pipe:1",
                ]
            else:
                filters = (
                    f"scale={self.offscreen_width}:{self.offscreen_height}:"
                    "force_original_aspect_ratio=decrease,"
                    f"pad={self.offscreen_width}:{self.offscreen_height}:(ow-iw)/2:(oh-ih)/2,"
                    "setsar=1"
                )
                cmd = [
                    self.ffmpeg_path,
                    "-hide_banner",
                    "-loglevel",
                    "error",
                    "-loop",
                    "1",
                    "-i",
                    str(asset),
                    "-vf",
                    filters,
                    "-pix_fmt",
                    "yuv420p",
                    "-f",
                    "mpegts",
                    "pipe:1",
                ]
            try:
                proc = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=log_handle,
                )
            except FileNotFoundError:
                return
            if proc.stdout is None:
                await proc.wait()
                return
            runtime.placeholder_active = True
            log_handle.write("[offscreen] Placeholder started.\n")
            log_handle.flush()
            try:
                while True:
                    chunk = await proc.stdout.read(64 * 1024)
                    if not chunk:
                        break
                    writer.write(chunk)
                    try:
                        await writer.drain()
                    except ConnectionResetError:
                        break
            except asyncio.CancelledError:
                with contextlib.suppress(ProcessLookupError):
                    proc.terminate()
                raise
            finally:
                runtime.placeholder_active = False
                log_handle.write("[offscreen] Placeholder finished.\n")
                log_handle.flush()
                if proc.stdout:
                    proc.stdout.close()
                await proc.wait()
                runtime.placeholder_task = None

        runtime.placeholder_task = asyncio.create_task(_run())
        if self.offscreen_placeholder_duration > 0:
            asyncio.create_task(self._cancel_placeholder_after(runtime, self.offscreen_placeholder_duration))

    async def _start_output_placeholder(
        self,
        runtime: _PipelineRuntime,
        writer: Optional[asyncio.StreamWriter],
        log_handle: TextIO,
    ) -> None:
        if not writer or not self._placeholder_available():
            return

        async def _run() -> None:
            filters = (
                f"scale={self.offscreen_width}:{self.offscreen_height}:"
                "force_original_aspect_ratio=decrease,"
                f"pad={self.offscreen_width}:{self.offscreen_height}:(ow-iw)/2:(oh-ih)/2,"
                "setsar=1"
            )
            cmd = [
                self.ffmpeg_path,
                "-hide_banner",
                "-loglevel",
                "error",
                "-loop",
                "1",
                "-i",
                str(self.offscreen_placeholder_asset),
                "-vf",
                filters,
                "-pix_fmt",
                "yuv420p",
                "-f",
                "mpegts",
                "pipe:1",
            ]
            try:
                proc = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=log_handle,
                )
            except FileNotFoundError:
                return
            if proc.stdout is None:
                await proc.wait()
                return
            runtime.output_placeholder_active = True
            log_handle.write("[offscreen] Output placeholder started.\n")
            log_handle.flush()
            try:
                while True:
                    chunk = await proc.stdout.read(64 * 1024)
                    if not chunk:
                        break
                    writer.write(chunk)
                    try:
                        await writer.drain()
                    except ConnectionResetError:
                        break
            except asyncio.CancelledError:
                with contextlib.suppress(ProcessLookupError):
                    proc.terminate()
                raise
            finally:
                runtime.output_placeholder_active = False
                log_handle.write("[offscreen] Output placeholder finished.\n")
                log_handle.flush()
                if proc.stdout:
                    proc.stdout.close()
                await proc.wait()
                runtime.output_placeholder_task = None

        runtime.output_placeholder_task = asyncio.create_task(_run())

    async def _stop_output_placeholder(self, runtime: _PipelineRuntime) -> None:
        task = runtime.output_placeholder_task
        if not task:
            return
        runtime.output_placeholder_task = None
        runtime.output_placeholder_active = False
        task.cancel()
        await asyncio.gather(task, return_exceptions=True)

    async def start_pipeline(
        self,
        *,
        op_id: str,
        channel: str,
        profile_name: str,
    ) -> PipelineStatus:
        if self._pipelines:
            await self._stop_all_pipelines()
        if op_id in self._pipelines:
            raise ValueError(f"Pipeline with op_id {op_id} already running")

        profile = self.profiles.get(profile_name)
        if not profile:
            raise ValueError(f"Unknown profile '{profile_name}'")

        listen_port = profile.listen_port or self.default_listen_port
        log_file = self.work_dir / f"{op_id}.log"
        outfile = self.work_dir / f"{op_id}.mpg"
        log_file.parent.mkdir(parents=True, exist_ok=True)

        status = PipelineStatus(
            op_id=op_id,
            channel=channel,
            profile=profile.name,
            started_at=time.time(),
            state="starting",
            listen_host=self.listen_host,
            listen_port=listen_port,
            outfile=outfile,
            log_file=log_file,
            pgid=None,
            ended_at=None,
            restart_count=0,
            last_error=None,
        )

        runtime = _PipelineRuntime(
            status=status,
            profile=profile,
            channel=channel,
        )
        self._pipelines[op_id] = runtime
        try:
            await self._spawn_process_chain(runtime)
        except Exception:
            self._pipelines.pop(op_id, None)
            raise
        status.state = "running"
        runtime.metrics_task = asyncio.create_task(self._metrics_poller(op_id))
        runtime.monitor_task = asyncio.create_task(self._monitor_pipeline(op_id))
        return status

    async def _spawn_process_chain(self, runtime: _PipelineRuntime) -> None:
        # Dispatch by strategy
        if self.strategy == "offscreen":
            await self._spawn_process_chain_offscreen(runtime)
            return
        status = runtime.status
        profile = runtime.profile
        channel = runtime.channel

        if runtime.log_handle and not runtime.log_handle.closed:
            runtime.log_handle.close()
        log_handle = status.log_file.open("a", encoding="utf-8")
        runtime.log_handle = log_handle

        log_handle.write(f"[direct] init channel={channel} profile={profile.name}\n")
        wrapper_cmd = self._build_direct_wrapper_command(
            profile=profile,
            channel=channel,
            listen_port=status.listen_port,
            op_id=status.op_id,
        )
        log_handle.write(f"[direct] launching pipeline: {' '.join(wrapper_cmd)}\n")
        log_handle.flush()

        proc = await asyncio.create_subprocess_exec(
            *wrapper_cmd,
            stdout=log_handle,
            stderr=log_handle,
            preexec_fn=os.setsid,
        )

        runtime.processes = [proc]
        runtime.pump_tasks = []
        runtime.metrics = PipelineMetrics(op_id=status.op_id)
        runtime.stop_requested = False
        try:
            runtime.status.pgid = os.getpgid(proc.pid)
        except ProcessLookupError:
            runtime.status.pgid = None
        runtime.status.started_at = time.time()
        runtime.status.ended_at = None
        runtime.status.restart_count = runtime.restart_attempts
        if runtime.restart_attempts == 0:
            runtime.status.last_error = None
        runtime.bytes_total = 0
        runtime.last_reported_bytes = 0
        runtime.last_activity_ts = time.time()
        runtime.client_connected = False

    def _build_offscreen_wrapper_command(
        self,
        *,
        channel: str,
        profile: TranscodeProfile,
        sink_name: str,
        display: str,
        width: int,
        height: int,
        listen_port: int = 0,
        op_id: str,
    ) -> List[str]:
        fifo_path = self.work_dir / f"{op_id}.offscreen.fifo"

        streamlink_cmd = [
            self.streamlink_path,
            "--stdout",
            f"twitch.tv/{channel}",
            self.offscreen_quality,
        ]
        if self.streamlink_disable_ads:
            streamlink_cmd.insert(1, "--twitch-disable-ads")

        xvfb_cmd = [
            "Xvfb",
            display,
            "-ac",
            "-screen",
            "0",
            f"{self.offscreen_width}x{self.offscreen_height}x24",
        ]

        mpv_frame = f"{width}x{height}"
        preproc_cmd = [
            self.ffmpeg_path,
            "-hide_banner",
            "-loglevel",
            "warning",
            "-fflags",
            "+genpts",
            "-thread_queue_size",
            "131072",
            "-i",
            "pipe:0",
            "-vf",
            (
                f"scale={width}:{height}:force_original_aspect_ratio=decrease,"
                f"pad={width}:{height}:(ow-iw)/2:(oh-ih)/2,"
                f"fps={self.offscreen_fps},setsar=1"
            ),
            "-af",
            "aresample=async=1:first_pts=0",
            "-c:v",
            "rawvideo",
            "-pix_fmt",
            "yuv420p",
            "-c:a",
            "pcm_s16le",
            "-f",
            "nut",
            "-",
        ]
        mpv_cmd = [
            "mpv",
            "--vo=x11",
            "--ao=pulse",
            f"--audio-device={sink_name}",
            "--fullscreen",
            "--geometry=0:0",
            f"--autofit={mpv_frame}",
            f"--autofit-larger={mpv_frame}",
            f"--autofit-smaller={mpv_frame}",
            "--no-keepaspect",
            "--no-keepaspect-window",
            "--no-border",
            "--force-window=yes",
            "--demuxer=lavf",
            "--demuxer-lavf-format=nut",
            "--cache=no",
            "--quiet",
            "-",
        ]
        capture_cmd = [
            self.ffmpeg_path,
            "-hide_banner",
            "-loglevel",
            "warning",
            "-fflags",
            "+genpts",
            "-use_wallclock_as_timestamps",
            "1",
            "-thread_queue_size",
            "131072",
            "-f",
            "x11grab",
            "-draw_mouse",
            "0",
            "-framerate",
            str(self.offscreen_fps),
            "-video_size",
            f"{width}x{height}",
            "-i",
            f"{display}+0,0",
            "-thread_queue_size",
            "131072",
        ]
        if self.offscreen_audio_delay:
            capture_cmd.extend(
                [
                    "-itsoffset",
                    f"{self.offscreen_audio_delay:.3f}",
                ]
            )
        capture_cmd.extend(
            [
                "-f",
                "pulse",
                "-i",
                f"{sink_name}.monitor",
                "-vf",
                f"fps={self.offscreen_fps},settb=1/{self.offscreen_fps},setpts=N/({self.offscreen_fps}*TB),format=yuv420p",
                "-af",
                "aresample=async=1:first_pts=0,asetpts=N/SR/TB",
                "-c:v",
                "rawvideo",
                "-pix_fmt",
                "yuv420p",
                "-c:a",
                "pcm_s16le",
                "-f",
                "nut",
                "-",
            ]
        )
        mbuffer_cmd = [
            self.mbuffer_path,
            "-m",
            self.offscreen_mbuffer,
            "-q",
        ]
        encode_cmd = [
            self.ffmpeg_path,
            "-hide_banner",
            "-loglevel",
            "warning",
            "-fflags",
            "+genpts",
            "-i",
            "pipe:0",
            "-use_wallclock_as_timestamps",
            "1",
            "-rw_timeout",
            "10000000",
            "-timeout",
            "10000000",
            "-flags",
            "+global_header",
            "-reconnect",
            "1",
            "-reconnect_at_eof",
            "1",
            "-reconnect_streamed",
            "1",
            "-reconnect_delay_max",
            "5",
            *profile.output_args,
            "-f",
            "mpeg",
            "pipe:1",
        ]

        placeholder_cmd = [
            "mpv",
            "--vo=x11",
            "--ao=pulse",
            f"--audio-device={sink_name}",
            "--fullscreen",
            "--geometry=0:0",
            f"--autofit={width}x{height}",
            "--no-border",
            "--no-osc",
            "--loop-file=yes",
            "--image-display-duration=inf",
            "--keep-open=yes",
            "--quiet",
            str(self.offscreen_placeholder_asset),
        ]

        def join(cmd: List[str]) -> str:
            return " ".join(shlex.quote(arg) for arg in cmd)

        placeholder_cmd_str = " ".join(shlex.quote(arg) for arg in placeholder_cmd)
        streamlink_str = join(streamlink_cmd)
        preproc_str = join(preproc_cmd)
        live_cmd_str = " | ".join([streamlink_str, preproc_str])
        mpv_str = join(mpv_cmd)
        capture_str = join(capture_cmd)
        mbuffer_str = join(mbuffer_cmd)
        encode_str = join(encode_cmd)
        sleep_delay = max(self.offscreen_capture_delay, 0.0)
        live_wait = max(self.offscreen_live_wait, 0.0)

        pipeline = textwrap.dedent(
            """
            set -e
            cleanup() {{
              if [ -n "$PLACEHOLDER_PID" ] && kill -0 "$PLACEHOLDER_PID" >/dev/null 2>&1; then kill "$PLACEHOLDER_PID" >/dev/null 2>&1 || true; fi
              if [ -n "$LIVE_PID" ] && kill -0 "$LIVE_PID" >/dev/null 2>&1; then kill "$LIVE_PID" >/dev/null 2>&1 || true; fi
              if [ -n "$SINK_ID" ]; then pactl unload-module "$SINK_ID" >/dev/null 2>&1 || true; fi
              if [ -n "$XVFB_PID" ]; then kill $XVFB_PID >/dev/null 2>&1 || true; fi
            }}
            trap 'cleanup; kill 0' INT TERM EXIT
            pulseaudio --check >/dev/null 2>&1 || pulseaudio --start >/dev/null 2>&1
            SINK_ID=$(pactl load-module module-null-sink sink_name={sink_name} latency_msec=30 2>/dev/null || true)
            Xvfb {display} -ac -screen 0 {width}x{height}x24 >/dev/null 2>&1 &
            XVFB_PID=$!
            for i in $(seq 1 100); do xdpyinfo -display {display} >/dev/null 2>&1 && break || sleep 0.1; done
            export DISPLAY={display}
            export SDL_VIDEODRIVER=x11
            export SDL_AUDIODRIVER=pulse
            export PULSE_SINK={sink_name}
            {placeholder_cmd_str} &
            PLACEHOLDER_PID=$!
            sleep {sleep_delay}
            ({capture_str} | {mbuffer_str} | {encode_str}) &
            CAPTURE_PID=$!
            sleep {live_wait}
            ({live_cmd_str} | {mpv_str}) &
            LIVE_PID=$!
            sleep {placeholder_runtime}
            if [ -n "$PLACEHOLDER_PID" ] && kill -0 "$PLACEHOLDER_PID" >/dev/null 2>&1; then kill "$PLACEHOLDER_PID" >/dev/null 2>&1 || true; fi
            wait "$CAPTURE_PID"
            """
        ).strip().format(
            sink_name=sink_name,
            display=display,
            width=width,
            height=height,
            placeholder_cmd_str=placeholder_cmd_str,
            live_cmd_str=live_cmd_str,
            mpv_str=mpv_str,
            sleep_delay=sleep_delay,
            capture_str=capture_str,
            mbuffer_str=mbuffer_str,
            encode_str=encode_str,
            live_wait=live_wait,
            placeholder_runtime=self.offscreen_placeholder_runtime,
        )

        return [
            sys.executable,
            "-u",
            str(self.tcp_wrapper_path),
            "--host",
            self.listen_host,
            "--port",
            str(listen_port),
            "--cmd",
            pipeline,
        ]

    async def _spawn_process_chain_offscreen(self, runtime: _PipelineRuntime) -> None:
        """Spawn the offscreen pipeline via tcp_wrapper so it runs only with a client."""
        status = runtime.status
        profile = runtime.profile
        channel = runtime.channel

        if runtime.log_handle and not runtime.log_handle.closed:
            runtime.log_handle.close()
        log_handle = status.log_file.open("a", encoding="utf-8")
        runtime.log_handle = log_handle

        def log_debug(message: str) -> None:
            self._log_offscreen(runtime, message)
        log_debug("initializing placeholder and live commands")

        log_debug(f"init channel={channel} profile={profile.name}")

        display = self.offscreen_display
        sink_name = os.getenv("PULSE_SINK", f"offscreen_{os.getpid()}_{status.op_id}")
        runtime.offscreen_sink_module_id = None
        runtime.offscreen_sink_name = sink_name
        runtime.offscreen_display = display
        wrapper_cmd = self._build_offscreen_wrapper_command(
            channel=channel,
            profile=profile,
            sink_name=sink_name,
            display=display,
            width=self.offscreen_width,
            height=self.offscreen_height,
            listen_port=status.listen_port,
            op_id=status.op_id,
        )

        log_debug("launching tcp_wrapper offscreen chain")
        proc = await asyncio.create_subprocess_exec(
            *wrapper_cmd,
            stdout=log_handle,
            stderr=log_handle,
            preexec_fn=os.setsid,
        )

        runtime.processes = [proc]
        runtime.pump_tasks = []
        runtime.metrics = PipelineMetrics(op_id=status.op_id)
        runtime.stop_requested = False
        try:
            runtime.status.pgid = os.getpgid(proc.pid)
        except Exception:
            runtime.status.pgid = None
        runtime.status.started_at = time.time()
        runtime.status.ended_at = None
        runtime.status.restart_count = runtime.restart_attempts
        if runtime.restart_attempts == 0:
            runtime.status.last_error = None
        runtime.bytes_total = 0
        runtime.last_reported_bytes = 0
        runtime.last_activity_ts = time.time()
        runtime.client_connected = False

    async def _monitor_pipeline(self, op_id: str) -> None:
        try:
            while True:
                runtime = self._pipelines.get(op_id)
                if not runtime:
                    return
                await asyncio.gather(*(proc.wait() for proc in runtime.processes))
                if runtime.pump_tasks:
                    await asyncio.gather(*runtime.pump_tasks, return_exceptions=True)
                runtime = self._pipelines.get(op_id)
                if not runtime:
                    return

                exit_codes = [proc.returncode for proc in runtime.processes]
                self._update_metrics(runtime)
                if runtime.metrics_task:
                    runtime.metrics_task.cancel()
                    await asyncio.gather(runtime.metrics_task, return_exceptions=True)
                    runtime.metrics_task = None

                if runtime.stop_requested:
                    runtime.status.state = "stopped"
                    runtime.status.ended_at = time.time()
                    self._update_metrics(runtime)
                    return

                if all(code == 0 for code in exit_codes):
                    runtime.status.state = "completed"
                    runtime.status.ended_at = time.time()
                    self._update_metrics(runtime)
                    return

                runtime.restart_attempts += 1
                runtime.status.restart_count = runtime.restart_attempts
                runtime.status.last_error = (
                    f"Pipeline exited unexpectedly (codes: {exit_codes})."
                )

                if runtime.restart_attempts > self.max_restarts:
                    runtime.status.state = "error"
                    runtime.status.ended_at = time.time()
                    self._update_metrics(runtime)
                    return

                runtime.status.state = "restarting"
                await asyncio.sleep(self.restart_delay)
                try:
                    await self._spawn_process_chain(runtime)
                except Exception as exc:
                    runtime.status.state = "error"
                    runtime.status.last_error = f"Restart failed: {exc}"
                    runtime.status.ended_at = time.time()
                    self._update_metrics(runtime)
                    return
                runtime.metrics_task = asyncio.create_task(self._metrics_poller(op_id))
                runtime.status.state = "running"
        except asyncio.CancelledError:
            return
        finally:
            runtime = self._pipelines.get(op_id)
            if runtime:
                await self._stop_placeholder(runtime)
                await self._stop_output_placeholder(runtime)
                if runtime.log_handle and not runtime.log_handle.closed:
                    runtime.log_handle.close()

    async def _metrics_poller(self, op_id: str) -> None:
        try:
            while True:
                runtime = self._pipelines.get(op_id)
                if not runtime:
                    return
                self._update_metrics(runtime)
                now = time.time()
                if runtime.bytes_total > runtime.last_reported_bytes:
                    runtime.last_reported_bytes = runtime.bytes_total
                    runtime.last_activity_ts = now
                    runtime.client_connected = True
                elif (
                    self.autostop_idle > 0
                    and runtime.client_connected
                    and now - runtime.last_activity_ts >= self.autostop_idle
                ):
                    await self._auto_stop(op_id, "Auto-Stop: Keine Datenaktivität erkannt.")
                    return
                if runtime.status.state != "running":
                    return
                await asyncio.sleep(self._metrics_interval)
        except asyncio.CancelledError:
            return
        finally:
            runtime = self._pipelines.get(op_id)
            if runtime:
                self._update_metrics(runtime)

    def _update_metrics(self, runtime: _PipelineRuntime) -> None:
        metrics = runtime.metrics
        if metrics is None:
            return
        now = time.time()
        metrics.bytes_total = runtime.bytes_total
        elapsed = max(0.0, now - runtime.status.started_at)
        metrics.out_time_ms = int(elapsed * 1000)
        if elapsed > 0:
            metrics.bitrate_kbps = int((runtime.bytes_total * 8) / elapsed / 1000)
        else:
            metrics.bitrate_kbps = 0
        metrics.updated_at = now

    async def _pump_stream(
        self,
        reader: Optional[asyncio.StreamReader],
        writer: Optional[asyncio.StreamWriter],
        runtime: Optional[_PipelineRuntime] = None,
        stop_reason_on_disconnect: Optional[str] = None,
    ) -> None:
        if reader is None or writer is None:
            return
        should_autostop = False
        try:
            while True:
                chunk = await reader.read(64 * 1024)
                if not chunk:
                    if stop_reason_on_disconnect:
                        should_autostop = True
                    break
                if runtime and runtime.placeholder_task and runtime.placeholder_active:
                    if runtime.log_handle and not runtime.log_handle.closed:
                        runtime.log_handle.write("[offscreen] live stream detected, stopping placeholder\n")
                        runtime.log_handle.flush()
                    await self._stop_placeholder(runtime)
                if runtime and runtime.output_placeholder_task and runtime.output_placeholder_active:
                    if runtime.log_handle and not runtime.log_handle.closed:
                        runtime.log_handle.write("[offscreen] live stream detected, stopping output placeholder\n")
                        runtime.log_handle.flush()
                    await self._stop_output_placeholder(runtime)
                writer.write(chunk)
                try:
                    await writer.drain()
                except ConnectionResetError:
                    should_autostop = True
                    stop_reason_on_disconnect = stop_reason_on_disconnect or "Auto-Stop: Clientverbindung beendet."
                    break
                if runtime:
                    runtime.bytes_total += len(chunk)
                    runtime.last_activity_ts = time.time()
                    runtime.client_connected = True
        except asyncio.CancelledError:
            raise
        except (BrokenPipeError, ConnectionResetError):
            if runtime:
                runtime.client_connected = False
                should_autostop = True
                stop_reason_on_disconnect = stop_reason_on_disconnect or "Auto-Stop: Clientverbindung beendet."
            return
        finally:
            try:
                if hasattr(writer, "can_write_eof") and writer.can_write_eof():
                    writer.write_eof()
            except (BrokenPipeError, ConnectionResetError, AttributeError):
                pass
            try:
                await writer.drain()
            except (ConnectionResetError, BrokenPipeError):
                pass
            try:
                writer.close()
                await writer.wait_closed()
            except Exception:
                pass
            if (
                runtime
                and stop_reason_on_disconnect
                and should_autostop
                and not runtime.stop_requested
            ):
                asyncio.create_task(self._auto_stop(runtime.status.op_id, stop_reason_on_disconnect))
            elif (
                runtime
                and should_autostop
                and not runtime.stop_requested
                and self.autostop_idle != 0
            ):
                asyncio.create_task(
                    self._auto_stop(
                        runtime.status.op_id,
                        "Auto-Stop: Clientverbindung beendet.",
                    )
                )

    async def _auto_stop(self, op_id: str, reason: str) -> None:
        runtime = self._pipelines.get(op_id)
        if not runtime or runtime.stop_requested:
            return
        runtime.status.last_error = reason
        runtime.status.state = "stopping"
        runtime.client_connected = False
        await self.stop_pipeline(op_id)

    async def stop_pipeline(self, op_id: str) -> bool:
        runtime = self._pipelines.get(op_id)
        if not runtime:
            return False
        await self._stop_placeholder(runtime)
        await self._stop_output_placeholder(runtime)
        runtime.stop_requested = True
        runtime.status.state = "stopping"
        pgid = runtime.status.pgid
        if pgid:
            with contextlib.suppress(ProcessLookupError):
                os.killpg(pgid, signal.SIGTERM)
        for proc in runtime.processes:
            if proc.returncode is None:
                with contextlib.suppress(ProcessLookupError):
                    os.kill(proc.pid, signal.SIGTERM)
        for task in runtime.pump_tasks:
            task.cancel()
        if runtime.metrics_task:
            current = asyncio.current_task()
            task = runtime.metrics_task
            if task is not current:
                task.cancel()
                await asyncio.gather(task, return_exceptions=True)
            runtime.metrics_task = None
        runtime.client_connected = False
        # Try to unload offscreen Pulse sink module if we created one
        if runtime.offscreen_sink_module_id:
            try:
                await asyncio.create_subprocess_exec(
                    "pactl",
                    "unload-module",
                    runtime.offscreen_sink_module_id,
                    stdout=asyncio.subprocess.DEVNULL,
                    stderr=asyncio.subprocess.DEVNULL,
                )
            except Exception:
                pass
        asyncio.create_task(self._ensure_shutdown(op_id))
        return True

    async def _ensure_shutdown(self, op_id: str) -> None:
        await asyncio.sleep(1)
        runtime = self._pipelines.get(op_id)
        if not runtime:
            return
        for proc in runtime.processes:
            if proc.returncode is None:
                with contextlib.suppress(ProcessLookupError):
                    os.kill(proc.pid, signal.SIGKILL)

    def remove_pipeline(self, op_id: str) -> None:
        runtime = self._pipelines.pop(op_id, None)
        if not runtime:
            return
        for task in (runtime.monitor_task, runtime.metrics_task):
            if task:
                task.cancel()
        for task in runtime.pump_tasks:
            task.cancel()
        if runtime.log_handle and not runtime.log_handle.closed:
            runtime.log_handle.close()
        fifo_path = self.work_dir / f"{op_id}.direct.fifo"
        with contextlib.suppress(OSError):
            fifo_path.unlink()

    async def _stop_all_pipelines(self) -> None:
        for existing_id in list(self._pipelines.keys()):
            await self.stop_pipeline(existing_id)
            self.remove_pipeline(existing_id)
